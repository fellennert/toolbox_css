{
  "hash": "e58e298799dd88b8041cb8ac5f0a8ac3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 3: `reticulate`\"\npublished-title: reticulate\nengine: knitr\nfreeze: auto\nbibliography: literature.bib\ncsl: ASA.csl\n---\n\n## Using Python in R with `reticulate`\n\nThe `reticulate` package provides a comprehensive set of tools for interoperability between Python and R. It allows you to call Python from R in a variety of ways, including importing Python modules, sourcing Python scripts, and using Python interactively from R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneeds(reticulate, tidyverse)\n```\n:::\n\n\n### Setting up Python\n\nBefore you can use Python in R, you need to ensure Python is installed on your system. The `reticulate` package will try to find Python automatically, but you can also specify which Python to use.\n\nFor a consistent experience across Windows and Mac, I recommend using `reticulate`'s built-in miniconda installation helper:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall_miniconda()\n```\n:::\n\n\nThis will install a minimal version of conda, which is a package and environment management system that works well for both R and Python.\n\nI would recommend using a conda environment for managing Python packages, as it helps avoid conflicts. When creating the environment, you can specify the Python version (this is important since not all Python versions are compatible with all package versions, unlike R) and packages you need. For example, to create an environment named \"toolbox_env\" with the `numpy` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconda_create(\"toolbox_env\", packages = c(\"python=3.9\", \"numpy\"))\n```\n:::\n\n\nIf you work in Positron, you might need to go to settings and select the Python interpreter from this environment. In RStudio, this can be done by navigating to `Tools` -\\> `Global Options` -\\> `Python` and selecting the appropriate interpreter. An overview of all conda environments and their paths can be found with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconda_list()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          name\n1         base\n2 selenium_env\n3  toolbox_env\n                                                                      python\n1                   /Users/felixlennert/Library/r-miniconda-arm64/bin/python\n2 /Users/felixlennert/Library/r-miniconda-arm64/envs/selenium_env/bin/python\n3  /Users/felixlennert/Library/r-miniconda-arm64/envs/toolbox_env/bin/python\n```\n\n\n:::\n:::\n\n\nSide note: you can remove an environment with\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconda_remove(\"r-reticulate\")\n```\n:::\n\n\n### Basic Python usage in R\n\nBefore you can get started, you need to tell `reticulate` to use this environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_condaenv(\"toolbox_env\", required = TRUE)\n```\n:::\n\n\nFurther, post-creation, you can install Python packages into this environment directly from R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npy_install(c(\"pandas\", \"scikit-learn\"))\n```\n:::\n\n\nIn Quarto documents, like this one, you can use Python chunks directly by using the `{python}` engine (i.e., by typing \\`\\`\\`\\{python\\} instead of \\`\\`\\`\\{r\\} when creating a code block):\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# This is a Python chunk\nimport pandas as pd\nimport numpy as np\n\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'score': [85.5, 92.0, 78.5, 88.0]\n}\n\ndf = pd.DataFrame(data)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name  age  score\n0    Alice   25   85.5\n1      Bob   30   92.0\n2  Charlie   35   78.5\n3    David   40   88.0\n```\n\n\n:::\n:::\n\n\nThe objects created in Python chunks are accessible in R if you make them globally accessible. For example, the `df` DataFrame created above can be accessed in R as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_r <- py$df\nprint(df_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     name age score\n1   Alice  25  85.5\n2     Bob  30  92.0\n3 Charlie  35  78.5\n4   David  40  88.0\n```\n\n\n:::\n:::\n\n\nHowever, note that this is only the case when knitting the document. If you run the chunks interactively, the objects won't be available in R.\n\nYou can enable availability behavior *while coding* by running Python code directly from R using the `py_run_string()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npy_run_string(\"\nimport pandas as pd\nimport numpy as np\n\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'score': [85.5, 92.0, 78.5, 88.0]\n}\n\ndf = pd.DataFrame(data)\nprint(df)\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name  age  score\n0    Alice   25   85.5\n1      Bob   30   92.0\n2  Charlie   35   78.5\n3    David   40   88.0\n```\n\n\n:::\n\n```{.r .cell-code}\n# This should work\nprint(py$df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     name age score\n1   Alice  25  85.5\n2     Bob  30  92.0\n3 Charlie  35  78.5\n4   David  40  88.0\n```\n\n\n:::\n:::\n\n\nThat's a bit cumbersome for larger code blocks, so you can also use `py_run_file()` to source a Python script. Note that the output objects might differ in type when accessed from R. For example, this `pandas` data frame becomes a named list in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npy_run_file(\"data/create_name_tbl.py\")\n\ndata_list <- py$data\ntypeof(data_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nThis is however easily fixable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_list |> bind_cols()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  name      age score\n  <chr>   <int> <dbl>\n1 Alice      25  85.5\n2 Bob        30  92  \n3 Charlie    35  78.5\n4 David      40  88  \n```\n\n\n:::\n:::\n\n\nAnother way of sharing objects between R and Python is of course by writing a file to disc. You can save data frames as CSV files in R and read them into Python, or vice versa. Make sure to set `index=False` when saving from Python to avoid an extra index column.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf.to_csv(\"data/people.csv\", index=False)\ndf.to_csv(\"data/people_w_index.csv\", index=True)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\"data/people.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 4 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): name\ndbl (2): age, score\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  name      age score\n  <chr>   <dbl> <dbl>\n1 Alice      25  85.5\n2 Bob        30  92  \n3 Charlie    35  78.5\n4 David      40  88  \n```\n\n\n:::\n\n```{.r .cell-code}\nread_csv(\"data/people_w_index.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNew names:\nRows: 4 Columns: 4\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): name dbl (3): ...1, age, score\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n   ...1 name      age score\n  <dbl> <chr>   <dbl> <dbl>\n1     0 Alice      25  85.5\n2     1 Bob        30  92  \n3     2 Charlie    35  78.5\n4     3 David      40  88  \n```\n\n\n:::\n:::\n\n\n### Further links\n\n-   [reticulate documentation](https://rstudio.github.io/reticulate/)",
    "supporting": [
      "3_reticulate_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}