{
  "hash": "32068540a4e48737b367a7f0495d62ae",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 4: Introduction to Python for R Users\"\npublished-title: python_for_r_users\nengine: knitr\nfreeze: auto\nbibliography: literature.bib\ncsl: ASA.csl\n---\n\n\n\n## Introduction\n\nThis tutorial introduces Python programming with a focus on comparisons to R. If you're familiar with R, you'll find many concepts translate directly, though the syntax differs. Python is a general-purpose programming language that's become increasingly popular in data science, offering powerful libraries for data manipulation, visualization, and machine learning.\n\n### Setting Up\n\nPython can be run in various environments:\n\n-   RStudio/Positron (see this blog post: [Using Python in RStudio](https://posit.co/blog/three-ways-to-program-in-python-with-rstudio/))\n-   Jupyter notebooks (similar to RMarkdown/Quarto)\n-   VSCode with Python extensions\n\nFor this tutorial, we'll use Python code chunks in Quarto, which can execute Python code just like they execute R code.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# This is a comment in Python (like # in R)\nprint(\"Hello from Python!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello from Python!\n```\n\n\n:::\n:::\n\n\n## Python Environments\n\n### What Are Environments?\n\nOne of the biggest differences between Python and R is how they handle packages and dependencies. In R, when you install a package with `install.packages()`, it typically goes into a central library that all your R projects share. Python takes a different approach with **virtual environments**.\n\nA Python environment is an isolated directory that contains: \n\n- A specific Python version \n- Installed packages and their specific versions \n- Dependencies for those packages\n\nImagine you have Project A that needs version 1.0 of a package, and Project B needs version 2.0 of the same package. In R, you'd typically have one version installed. In Python, you create separate environments for each project.\n\n### Common Environment Tools\n\nWe will use conda for all things environment management in this tutorial. Other options include: - `venv` (built-in Python tool) - `virtualenv` (third-party tool)\n\n`conda` is more powerful and manages both Python versions and packages. It's popular in data science.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Create environment with specific Python version\nconda create -n toolbox_env python=3.9\n\n# Activate\nconda activate toolbox_env\n\n# Install packages\nconda install pandas numpy matplotlib selenium openpyxl\n\n# Deactivate\nconda deactivate\n```\n:::\n\n\nOr do it the `reticulate` way in Quarto:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreticulate::conda_create(\"toolbox_env\", packages = \"python=3.9\")\nreticulate::conda_install(\"toolbox_env\", packages = c(\"pandas\", \"numpy\", \"matplotlib\", \"selenium\", \"openpyxl\"))\nreticulate::use_condaenv(\"toolbox_env\", required = TRUE)\n```\n:::\n\n\n\n### Why Environments Matter for This Tutorial\n\nIf you're working through this tutorial:\n\n1.  **Using Jupyter/Quarto**: These typically run in their own environment. Your code chunks will execute in whatever environment is active.\n\n2.  **Installing packages**: When we eventually use packages like `NumPy`, `selenium`, or `Pandas`, you'll want to install them in an environment:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nconda install pandas numpy matplotlib selenium\n```\n:::\n\n\n3.  **Checking your environment**: You can see what's installed with:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nconda list            # for conda\n```\n:::\n\n\n### Quick Setup Recommendation\n\nIf you have not created your environment using `reticulate` yet, I recommend doing it manually in the console.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Create a dedicated environment\nconda create -n toolbox_env python=3.9 pandas numpy matplotlib jupyter\n\n# Activate it\nconda activate toolbox_env\n\n# When working on exercises, make sure this environment is active!\n```\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nThink of it this way: In R, you might use RStudio Projects to organize your work. In Python, you use Projects *plus* environments to isolate not just files, but also package versions.\n:::\n\n### Checking Your Current Environment\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport sys\n\n# Where is Python running from?\nprint(f\"Python executable: {sys.executable}\")\n\n# What version?\nprint(f\"Python version: {sys.version}\")\n```\n:::\n\n\nIf you're using conda, you can also check in your terminal:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nconda info --envs  # List all environments\n```\n:::\n\n\n## Data Types\n\nPython has several fundamental data types. Unlike R, where everything is a vector by default, Python distinguishes between individual values (scalars) and collections. You will also use an assignment operator `=` instead of `<-`.\n\n### Numbers\n\nPython has two main numeric types: integers (`int`) and floating-point numbers (`float`).\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Integer\nx = 42\nprint(type(x))  # Check the type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'int'>\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n42\n```\n\n\n:::\n\n```{.python .cell-code}\n# Float\ny = 3.14159\nprint(type(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'float'>\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.14159\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nIn R, you'd use `class()` instead of `type()`. R doesn't strictly distinguish between integers and doubles unless you explicitly create an integer with `42L`.\n:::\n\n### Strings\n\nStrings represent text data. Python treats single quotes `'` and double quotes `\"` identically (unlike R where they're essentially the same but double quotes are conventional).\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Strings in Python\ngreeting = \"Hello\"\nname = 'World'\n\n# String concatenation uses +\nmessage = greeting + \" \" + name + \"!\"\nprint(message)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello World!\n```\n\n\n:::\n\n```{.python .cell-code}\n# Or use f-strings (formatted string literals) -- Python 3.6+\nmessage_formatted = f\"{greeting} {name}!\"\nprint(message_formatted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello World!\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nIn R, you'd use `paste()` or `paste0()` for concatenation, or `str_c()` from the tidyverse. Python's f-strings are similar to `glue::glue()` in R.\n:::\n\n### Booleans\n\nBoolean values are `True` and `False` (note the capitalization - this matters in Python!).\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Booleans in Python\nis_python_fun = True\nis_this_hard = False\n\nprint(is_python_fun)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(type(is_python_fun))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'bool'>\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR uses `TRUE` and `FALSE` (all caps), while Python uses `True` and `False` (capitalized). Python is case-sensitive, so `true` would throw an error.\n:::\n\n### None\n\nPython's equivalent of R's `NULL` or `NA` is `None`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# None represents absence of value\nnothing = None\nprint(nothing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNone\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(type(nothing))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'NoneType'>\n```\n\n\n:::\n:::\n\n\n## Collections: Lists, Tuples, and Dictionaries\n\nPython has several built-in collection types. These are roughly analogous to R's vectors and lists, but with important differences.\n\n### Lists\n\nPython lists are ordered, mutable (changeable) collections. They're similar to R's lists, not R's atomic vectors.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Creating a list\nnumbers = [1, 2, 3, 4, 5]\nmixed_list = [1, \"two\", 3.0, True]  # Can contain different types\n\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4, 5]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(mixed_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 'two', 3.0, True]\n```\n\n\n:::\n:::\n\n\n**Indexing**: Python uses 0-based indexing (the first element is at position 0), unlike R's 1-based indexing.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Accessing elements\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\nprint(fruits[0])      # First element (R would use fruits[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\napple\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(fruits[-2])     # Last element (negative indexing from end)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncherry\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(fruits[1:3])    # Slicing: elements 1 and 2 (end index is exclusive)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['banana', 'cherry']\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR's `c(1, 2, 3, 4, 5)` creates an atomic vector. Python's `[1, 2, 3, 4, 5]` is more like R's `list(1, 2, 3, 4, 5)`, though it can be used for numeric operations when converted to a NumPy array.\n:::\n\nSome common list operations:\n\n::: {.cell}\n\n```{.python .cell-code}\n# List operations\nnumbers = [1, 2, 3]\n\n# Append (like R's c() or append())\nnumbers.append(4)\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Extend with another list\nnumbers.extend([5, 6])\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4, 5, 6]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Length\nprint(len(numbers))  # R's length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6\n```\n\n\n:::\n:::\n\n\n### Tuples\n\nTuples are like lists but immutable (can't be changed after creation). They use parentheses `()` instead of square brackets.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Creating a tuple\ncoordinates = (10, 20)\nprint(coordinates)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(10, 20)\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(type(coordinates))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'tuple'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Accessing works the same as lists\nprint(coordinates[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n10\n```\n\n\n:::\n\n```{.python .cell-code}\n\n# But you can't modify them\n#coordinates[0] = 15  # This would raise an error!\n```\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR doesn't have a direct equivalent to tuples, though you could think of them as named lists that are \"frozen.\"\n:::\n\n### Dictionaries\n\nDictionaries store key-value pairs. They're similar to R's named lists or named vectors.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Creating a dictionary\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"city\": \"Leipzig\"\n}\n\nprint(person)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{'name': 'Alice', 'age': 30, 'city': 'Leipzig'}\n```\n\n\n:::\n\n```{.python .cell-code}\n# Accessing values by key\nprint(person[\"name\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAlice\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(person[\"age\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n30\n```\n\n\n:::\n\n```{.python .cell-code}\n# Adding new key-value pairs\nperson[\"occupation\"] = \"Data Scientist\"\nprint(person)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{'name': 'Alice', 'age': 30, 'city': 'Leipzig', 'occupation': 'Data Scientist'}\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\n\nThis is similar to:\n\n::: {.cell}\n\n```{.r .cell-code}\nperson <- list(\n  name = \"Alice\",\n  age = 30,\n  city = \"Leipzig\"\n)\nperson$name  # or person[[\"name\"]]\n```\n:::\n\n:::\n\n## Simple Operations\n\n### Arithmetic Operations\n\nPython supports standard arithmetic operators, similar to R.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Basic arithmetic\na = 11\nb = 3\n\na + b       # Addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n14\n```\n\n\n:::\n\n```{.python .cell-code}\na - b       # Subtraction\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8\n```\n\n\n:::\n\n```{.python .cell-code}\na * b       # Multiplication\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n33\n```\n\n\n:::\n\n```{.python .cell-code}\na / b       # Division (always returns float)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.6666666666666665\n```\n\n\n:::\n\n```{.python .cell-code}\na // b      # Floor division (integer division - R uses %/%)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n```\n\n\n:::\n\n```{.python .cell-code}\na % b       # Modulus (remainder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n\n```{.python .cell-code}\na ** b      # Exponentiation (R uses a^b or a**b in newer versions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1331\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\n\nMost operators are the same. \n\nKey differences: \n\n- `/` always returns float in Python 3 (R returns integer if both are integers) \n- `//` for integer division (R: `%/%`) \n- `**` for exponentiation (R traditionally uses `^`, though `**` now works)\n\n::: \n\n### Comparison Operations\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Comparison operators\nx = 5\ny = 10\n\nx == y #Equal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n\n```{.python .cell-code}\nx != y # Not equal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n\n```{.python .cell-code}\nx > y  # Greater than\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n\n```{.python .cell-code}\nx <= y # Less than or equal to\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nSame operators, but Python uses `!=` for \"not equal\" (R can use `!=` or `<>`).\n:::\n\n### Logical Operations\n\nPython uses words instead of symbols for logical operations.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Logical operators\na = True\nb = False\n\na and b # R equ: a & b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n\n```{.python .cell-code}\na or b # R equ: a | b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n\n```{.python .cell-code}\nnot a # R equ: !a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\n\n- Python: `and`, `or`, `not` \n- R: `&`, `|`, `!` (for element-wise); `&&`, `||` (for scalar)\n\n::: \n\n## Flow Control with `if`, `elif`, `else`\n\nSometimes you want your code to only run in specific cases. Python uses if statements for conditional execution.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Basic if statement\nx = 3\n\nif x <= 5:\n    print(\"x is smaller than or equal to 5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx is smaller than or equal to 5\n```\n\n\n:::\n:::\n\n\nAdd an else block for an alternative action:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 10\n\nif x <= 5:\n    print(\"x is smaller than or equal to 5\")\nelse:\n    print(\"x is greater than 5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx is greater than 5\n```\n\n\n:::\n:::\n\n\n### elif - Multiple Conditions\n\nWhen you need to check multiple conditions sequentially, use `elif` (short for \"else if\"). Python will check each condition in order and execute the first block where the condition is `True`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nscore = 75\n\nif score >= 90:\n    print(\"Grade: A\")\nelif score >= 80:\n    print(\"Grade: B\")\nelif score >= 70:\n    print(\"Grade: C\")\nelif score >= 60:\n    print(\"Grade: D\")\nelse:\n    print(\"Grade: F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGrade: C\n```\n\n\n:::\n:::\n\n\nYou can have as many elif statements as you need. Python checks them from top to bottom and stops at the first `True` condition. Note that the final `else` is optional but highly recommended as a catch-all.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemperature = 25\n\nif temperature < 0:\n    print(\"Freezing!\")\nelif temperature < 10:\n    print(\"Cold\")\nelif temperature < 20:\n    print(\"Cool\")\nelif temperature < 30:\n    print(\"Warm\")\nelse:\n    print(\"Hot!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWarm\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nComparison to R: R uses else if (two words) instead of elif:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemperature = 25\nif (temperature < 0) {\n  print(\"Freezing\")\n} else if (temperature >= 10) {\n  print(\"Cold\")\n} else if (temperature < 20) {\n  print(\"Cool\")\n} else if (temperature < 30) {\n  print(\"Warm\")\n} else {\n  print(\"Hot!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Cold\"\n```\n\n\n:::\n:::\n\n\n::: \n\nImportant: The condition must evaluate to a single boolean value (True or False).\n\n## Functions\n\nFunctions allow you to package code into reusable blocks. Just like in R, functions are essential for writing clean, maintainable code that follows the DRY (Don't Repeat Yourself) principle.\n\n### Defining Functions\nThe basic syntax for defining a function in Python:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef function_name(parameter1, parameter2):\n    \"\"\"This is a docstring - describes what the function does.\"\"\"\n    # Function body\n    result = parameter1 + parameter2\n    return result\n\n# Call the function\nanswer = function_name(5, 3)\nanswer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(parameter1, parameter2) {\n  result <- parameter1 + parameter2\n  return(result)\n}\n```\n:::\n\n\n:::\n\n### A Simple Example\n\n::: {.cell}\n\n```{.python .cell-code}\ndef greet(name):\n    \"\"\"Greet someone by name.\"\"\"\n    return f\"Hello, {name}!\"\n\ngreet(\"Alice\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'Hello, Alice!'\n```\n\n\n:::\n\n```{.python .cell-code}\ngreet(\"Bob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'Hello, Bob!'\n```\n\n\n:::\n\n```{.python .cell-code}\n\n### Hint: Python coders tend to use \"\" around real text/natural language and '' around symbol-like expressions (e.g., column names -- see below)\n```\n:::\n\n\n### Default Arguments\nYou can provide default values for parameters, just like in R.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef greet_with_title(name, title = \"Dr.\"):\n    \"\"\"Greet someone with their title.\"\"\"\n    return f\"Hello, {title} {name}!\"\n\ngreet_with_title(\"Smith\")                    # Uses default title\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'Hello, Dr. Smith!'\n```\n\n\n:::\n\n```{.python .cell-code}\ngreet_with_title(\"Smith\", \"Prof.\")           # Overrides default\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'Hello, Prof. Smith!'\n```\n\n\n:::\n\n```{.python .cell-code}\ngreet_with_title(\"Smith\", title = \"Mr.\")       # Named argument (more explicit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'Hello, Mr. Smith!'\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrgreet_with_title <- function(name, title = \"Dr.\") {\n  paste0(\"Hello, \", title, \" \", name, \"!\")\n}\n```\n:::\n\n::: \n\n### `return`\n\nPer the [official style guide](https://peps.python.org/pep-0008/#programming-recommendations) it is idiomatic to be consistent with `return` statements:\n\n> Be consistent in return statements. Either all return statements in a function should return an expression, or none of them should. If any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None, and an explicit return statement should be present at the end of the function (if reachable)\n\n::: {.callout-tip title=\"Compared to R\"}\n\nThe object created in the last call will automatically be returned. `return(object)` shall be avoided unless you need an early return.\n\n::: \n\n\n### Multiple Return Values\nPython can return multiple values as a tuple (similar to R's lists).\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef calculate_stats(numbers):\n    \"\"\"Calculate mean and standard deviation.\"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    \n    # Calculate standard deviation\n    squared_diff = [(x - mean) ** 2 for x in numbers] # this is a list comprehension, an abbreviated for loop\n    variance = sum(squared_diff) / n\n    std_dev = variance ** 0.5\n    \n    return mean, std_dev  # Returns a tuple\n\ndata = [2, 4, 4, 4, 5, 5, 7, 9]\n\nmean_value, std_value = calculate_stats(data) # make sure to define both objects, or unpack the tuple later\nmean_value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5.0\n```\n\n\n:::\n\n```{.python .cell-code}\nstd_value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2.0\n```\n\n\n:::\n\n```{.python .cell-code}\n#this is the same as:\nresults = calculate_stats(data)\nmean_value = results[0]\nstd_value = results[1]\nmean_value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5.0\n```\n\n\n:::\n\n```{.python .cell-code}\nstd_value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2.0\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nComparison to R: R typically returns a list or vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrcalculate_stats <- function(numbers) {\n  list(mean = mean(numbers), sd = sd(numbers))\n}\n```\n:::\n\n\n::: \n\n### Docstrings\nPython uses triple-quoted strings (\"\"\"...\"\"\") right after the function definition to document what the function does. This is similar to `roxygen2` comments in R.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef convert_temperature(celsius):\n    \"\"\"\n    Convert temperature from Celsius to Fahrenheit.\n    \n    Parameters:\n    -----------\n    celsius : float\n        Temperature in Celsius\n        \n    Returns:\n    --------\n    float\n        Temperature in Fahrenheit\n    \"\"\"\n    fahrenheit = (celsius * 9/5) + 32\n    return fahrenheit\n\nconvert_temperature(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n32.0\n```\n\n\n:::\n\n```{.python .cell-code}\nconvert_temperature(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n212.0\n```\n\n\n:::\n\n```{.python .cell-code}\n\n#'You can access the docstring with `help()` in an interactive session (e.g., Jupyter):\n#help(convert_temperature)\n```\n:::\n\n\n### Lambda Functions (Anonymous Functions)\n\nPython has lambda functions for short, one-line functions. These are similar to R's anonymous functions `function(x) x + 1` or the shorthand `\\(x) x + 1` in purrr.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Regular function\ndef add_ten(x):\n    return x + 10\n\n# Lambda function (anonymous)\nadd_ten_lambda = lambda x: x + 10\n\nadd_ten(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n15\n```\n\n\n:::\n\n```{.python .cell-code}\nadd_ten_lambda(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n15\n```\n\n\n:::\n:::\n\n\nLambda functions are especially useful when you need a simple function as an argument:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Sort a list of tuples by the second element\npairs = [(1, 'one'), (3, 'three'), (2, 'two')]\nsorted_pairs = sorted(pairs, key=lambda x: x[1])\nsorted_pairs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[(1, 'one'), (3, 'three'), (2, 'two')]\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR equivalent\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_ten <- function(x) x + 10\n# or in purrr\nadd_ten <- \\(x) x + 10\n```\n:::\n\n:::\n\n### Variable Scope\n\nPython follows similar scoping rules to R: variables defined inside functions are local to that function.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 10  # Global variable\n\ndef modify_variable():\n    x = 5  # Local variable - doesn't affect global x\n    return x\n\nmodify_variable()  # Returns 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5\n```\n\n\n:::\n\n```{.python .cell-code}\nx                  # Still 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n10\n```\n\n\n:::\n:::\n\n\nTo modify a global variable inside a function, you need the global keyword (though this is generally discouraged):\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncounter = 0\n\ndef increment_counter():\n    global counter\n    counter += 1\n    return counter\n\nincrement_counter()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n```\n\n\n:::\n\n```{.python .cell-code}\nincrement_counter()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n\n```{.python .cell-code}\ncounter\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nComparison to R: R uses <<- for assigning to parent environments, which is also discouraged.\n:::\n\n## Loops\n\nLoops allow you to repeat operations. Python has `for` loops and `while` loops, similar to R.\n\n### For Loops\n\n`for` loops in Python iterate over sequences (lists, tuples, strings, ranges, etc.).\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Basic for loop\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\nfor fruit in fruits:\n    print(f\"I like {fruit}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nI like apple\nI like banana\nI like cherry\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR's equivalent would be:\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits = c(\"apple\", \"banana\", \"cherry\")\nfor (fruit in fruits) {\n  print(paste(\"I like\", fruit))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I like apple\"\n[1] \"I like banana\"\n[1] \"I like cherry\"\n```\n\n\n:::\n:::\n\n::: \n\n#### The range() Function\n\n`range()` generates a sequence of numbers and is commonly used with `for` loops. It's similar to R's `seq()` or `:` operator.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# range(stop) - from 0 to stop-1\nfor i in range(5):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0\n1\n2\n3\n4\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# range(start, stop) - from start to stop-1\nfor i in range(2, 7):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n3\n4\n5\n6\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# range(start, stop, step) - with custom step\nfor i in range(0, 10, 2):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0\n2\n4\n6\n8\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR equivalents:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 0:4) { }           # range(5)\nfor (i in 2:6) { }           # range(2, 7)\nfor (i in seq(0, 8, by=2)) { } # range(0, 10, 2)\n```\n:::\n\n:::\n\n### Enumerate\nWhen you need both the index and the value, use `enumerate()`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# enumerate provides index and value\ncolors = [\"red\", \"green\", \"blue\"]\nenumerate(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<enumerate object at 0x122b01480>\n```\n\n\n:::\n\n```{.python .cell-code}\nfor index, color in enumerate(colors):\n    print(f\"Color {index}: {color}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nColor 0: red\nColor 1: green\nColor 2: blue\n```\n\n\n:::\n\n```{.python .cell-code}\n# Start counting from 1 instead of 0\nfor index, color in enumerate(colors, start=1):\n    print(f\"Color {index}: {color}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nColor 1: red\nColor 2: green\nColor 3: blue\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR's `seq_along()` is similar:\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors = c(\"red\", \"green\", \"blue\")\nfor (i in seq_along(colors)) {\n  print(paste(\"Color\", i, \":\", colors[i]))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Color 1 : red\"\n[1] \"Color 2 : green\"\n[1] \"Color 3 : blue\"\n```\n\n\n:::\n:::\n\n::: \n\n### Nested Loops\n\nYou can nest loops just like in R.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Nested loops - multiplication table\nfor i in range(1, 4):\n    for j in range(1, 4):\n        print(f\"{i} x {j} = {i * j}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 x 1 = 1\n1 x 2 = 2\n1 x 3 = 3\n2 x 1 = 2\n2 x 2 = 4\n2 x 3 = 6\n3 x 1 = 3\n3 x 2 = 6\n3 x 3 = 9\n```\n\n\n:::\n:::\n\n\n### List Comprehensions\n\nOne of Python's most powerful features is list comprehensions -- a concise way to create lists. This is similar to R's `sapply()` or `purrr::map()`. \n\nNow that you understand `for` loops, list comprehensions will make more sense as they're essentially condensed `for` loops. List comprehensions will yield a list.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Traditional loop approach\nsquares = [] # define list\nfor i in range(1, 6):\n    squares.append(i ** 2) # build list as you go -- more efficient than vector growing in R\nprint(squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 4, 9, 16, 25]\n```\n\n\n:::\n\n```{.python .cell-code}\n# List comprehension - more Pythonic\nsquares = [i ** 2 for i in range(1, 6)]\nprint(squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 4, 9, 16, 25]\n```\n\n\n:::\n\n```{.python .cell-code}\n# With condition (like dplyr::filter)\n#[expression *for* item *in* iterable *if* condition]\neven_squares = [i ** 2 for i in range(1, 11) if i % 2 == 0]\nprint(even_squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[4, 16, 36, 64, 100]\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip title=\"Compared to R\"}\nR equivalent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneeds(tidyverse)\nsquares <- sapply(1:5, function(x) x^2)\n# or with purrr\nsquares <- map(1:5, \\(x) x^2)\n```\n:::\n\n\n::: \n\nThe general syntax for list comprehensions is:\n\n`[expression *for* item *in* iterable *if* condition]`\n\nThis reads almost like English: \n\"Create a list of expression *for* each item *in* iterable *if* condition is true.\"\n\n### While Loops\n\n`while` loops continue executing as long as a condition is `True`. They're identical in concept to R's while loops.\n\n::: {.cell}\n\n```{.python .cell-code}\n# Basic while loop\ncount = 0\n\nwhile count < 5:\n    print(f\"Count is: {count}\")\n    count += 1  # Increment \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCount is: 0\nCount is: 1\nCount is: 2\nCount is: 3\nCount is: 4\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"Loop finished!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLoop finished!\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nVery similar syntax, though Python uses count += 1 instead of count <- count + 1.\n:::\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# while loop with user input simulation\n# Let's simulate checking until we find a value\nimport random\n\ntarget = 7\nattempts = 0\nguess = 0\n\nwhile guess != target:\n    guess = random.randint(1, 10)\n    attempts += 1\n    print(f\"Attempt {attempts}: guessed {guess}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAttempt 1: guessed 10\nAttempt 2: guessed 8\nAttempt 3: guessed 3\nAttempt 4: guessed 3\nAttempt 5: guessed 3\nAttempt 6: guessed 5\nAttempt 7: guessed 3\nAttempt 8: guessed 6\nAttempt 9: guessed 1\nAttempt 10: guessed 1\nAttempt 11: guessed 10\nAttempt 12: guessed 5\nAttempt 13: guessed 8\nAttempt 14: guessed 9\nAttempt 15: guessed 5\nAttempt 16: guessed 9\nAttempt 17: guessed 7\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f\"Found {target} in {attempts} attempts!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFound 7 in 17 attempts!\n```\n\n\n:::\n:::\n\n\n### `break` and `continue`\n\nControl loop execution with `break` and `continue`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# break - exit the loop immediately\nfor i in range(10):\n    if i == 5:\n        break\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0\n1\n2\n3\n4\n```\n\n\n:::\n\n```{.python .cell-code}\n# continue - skip rest of current iteration\nfor i in range(10):\n    if i % 2 == 0:  # Skip even numbers\n        continue\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n3\n5\n7\n9\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\n`break` and `next` work the same way (next in R is continue in Python).\n::: \n\n### Practical Examples\n\n**Example 1: Filter and Transform Data** \nLet's say we have a list of student grades and we want to filter out those who passed (grade >= 70) and calculate the average grade.\n\n::: {.cell}\n\n```{.python .cell-code}\n# Sample data\nstudents = [\n    {\"name\": \"Alice\", \"grade\": 85},\n    {\"name\": \"Bob\", \"grade\": 72},\n    {\"name\": \"Charlie\", \"grade\": 90},\n    {\"name\": \"Diana\", \"grade\": 68},\n    {\"name\": \"Eve\", \"grade\": 95}\n]\n\n# Filter students who passed (grade >= 70)\npassing_students = [s for s in students if s[\"grade\"] >= 70]\n\nprint(\"Passing students:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPassing students:\n```\n\n\n:::\n\n```{.python .cell-code}\nfor student in passing_students:\n    print(f\"{student['name']}: {student['grade']}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAlice: 85\nBob: 72\nCharlie: 90\nEve: 95\n```\n\n\n:::\n\n```{.python .cell-code}\n# Calculate average grade\ngrades = [s[\"grade\"] for s in students]\naverage = sum(grades) / len(grades)\nprint(f\"\\nClass average: {average:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nClass average: 82.00\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Compared to R\"}\nThis is similar to using `dplyr::filter()` and `summarize()`.\n:::\n\n**Example 2: FizzBuzz** \n\nA classic programming exercise - counting with special rules.\n\n::: {.cell}\n\n```{.python .cell-code}\n# FizzBuzz: Print numbers 1-20, but:\n# - \"Fizz\" for multiples of 3\n# - \"Buzz\" for multiples of 5\n# - \"FizzBuzz\" for multiples of both\n\nfor i in range(1, 21):\n    if i % 3 == 0 and i % 5 == 0:\n        print(\"FizzBuzz\")\n    elif i % 3 == 0:\n        print(\"Fizz\")\n    elif i % 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n```\n\n\n:::\n:::\n\n\n\n## Key Python Conventions\n\n### Indentation\n\nPython uses indentation to define code blocks (unlike R which uses {}). This is not optional -- incorrect indentation will cause errors!\n\n# Correct indentation\n\n\n::: {.cell}\n\n```{.python .cell-code}\nif True:\n    print(\"This is indented\")\n    print(\"This too\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis is indented\nThis too\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"This is not in the if block\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis is not in the if block\n```\n\n\n:::\n:::\n\n\nImportant: Use 4 spaces (not tabs) for indentation. Most Python editors handle this automatically.\n\n### Naming Conventions\n\nPython follows PEP 8 style guide:\n\n- Variables and functions: snake_case (like R's tidyverse)\n- Constants: UPPER_CASE\n- Classes: PascalCase\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Good Python style\nstudent_name = \"Alice\"\nMAX_ATTEMPTS = 3\n\ndef calculate_average(values):\n    return sum(values) / len(values)\n```\n:::\n\n\n\n## Finally: The Zen of Python\nPython has a philosophy! Type `import this` to see it:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport this\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n**Exercise 1: Temperature Converter**\nWrite a program that converts temperatures between Celsius and Fahrenheit.\nFormula: $F = (C \\times 9/5) + 32$\n\na. Convert each to Fahrenheit using a for loop\nb. Print the results\nc. Store each Celsius value and its Fahrenheit equivalent in a DataFrame.\n\n<details>\n  <summary>Solution. Click to expand!</summary>\n\n::: {.cell}\n\n```{.python .cell-code}\ntemperatures_celsius = [0, 10, 20, 30, 40]\ntemperatures_fahrenheit = []\n\nfor temp in temperatures_celsius:\n    fahrenheit = (temp * 9/5) + 32\n    temperatures_fahrenheit.append(fahrenheit)\n\ntemperatures_fahrenheit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[32.0, 50.0, 68.0, 86.0, 104.0]\n```\n\n\n:::\n:::\n\n</details>\n\n**Exercise 2: Word Counter**\n\nGiven a sentence, count how many times each word appears. \n\nHint: Use `sentence.split()` to get a list of words, and a dictionary to store counts. The operator in yields True if an element is in another list, e.g., `if word in word_counts`\n\n\n<details>\n  <summary>Solution. Click to expand!</summary>\n\n::: {.cell}\n\n```{.python .cell-code}\npython_sentence = \"the quick brown fox jumps over the lazy dog the fox\"\n\n# Split sentence into words\nwords = python_sentence.split()\n\n# Count occurrences using a dictionary\nword_counts = {}\nfor word in words:\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\n\nword_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{'the': 3, 'quick': 1, 'brown': 1, 'fox': 2, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1}\n```\n\n\n:::\n\n```{.python .cell-code}\n# Expected output: {'the': 3, 'quick': 1, 'brown': 1, ...}\n```\n:::\n\n</details>\n\n**Exercise 3: Prime Numbers**\n\nWrite a function that checks if a number is prime. Then use it to find all prime numbers between 1 and 50.\n\n<details>\n  <summary>Solution. Click to expand!</summary>\n\n::: {.cell}\n\n```{.python .cell-code}\ndef is_prime(n):\n    \"\"\"Check if a number is prime\"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, n):\n        if n % i == 0:\n            return False\n    return True\n\nis_prime(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n\n```{.python .cell-code}\n# Find all prime numbers between 1 and 50\nprimes = []\nfor num in range(1, 51):\n    if is_prime(num):\n        primes.append(num)\n\nprimes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n```\n\n\n:::\n:::\n\n</details>\n\n**Exercise 4: List Manipulation**\n\na. Create a list of numbers from 1 to 20:\nb. Create a new list with only even numbers\nc. Create a new list with squares of odd numbers\nd. Calculate the sum of numbers divisible by 3\n\n<details>\n  <summary>Solution. Click to expand!</summary>\n\n::: {.cell}\n\n```{.python .cell-code}\n# a. Create a list of numbers from 1 to 20\nnumbers = list(range(1, 21))\n\n# b. Create a new list with only even numbers\neven_numbers = [num for num in numbers if num % 2 == 0]\neven_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n```\n\n\n:::\n\n```{.python .cell-code}\n# c. Create a new list with squares of odd numbers\nodd_squares = [num ** 2 for num in numbers if num % 2 != 0]\nodd_squares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 9, 25, 49, 81, 121, 169, 225, 289, 361]\n```\n\n\n:::\n\n```{.python .cell-code}\n# d. Calculate the sum of numbers divisible by 3\ndivisible_by_3 = [num for num in numbers if num % 3 == 0]\nsum(divisible_by_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n63\n```\n\n\n:::\n:::\n\n</details>\nThe syntax might be different, but the concepts you know from R will translate well!\n\n## Further Resources\n\n-  [Official Python Tutorial](https://docs.python.org/3/tutorial/)\n-  [Learn Python the Hard Way](https://learnpythonthehardway.org/)\n-  [Automate the Boring Stuff with Python](https://automatetheboringstuff.com/)\n-  [Real Python](https://realpython.com/)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}