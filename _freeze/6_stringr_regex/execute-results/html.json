{
  "hash": "3a96201581324a13d0ee963c15beabc2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 6: `stringr` and RegExes\"\npublished-title: stringr_regex\nengine: knitr\nfreeze: auto\nbibliography: literature.bib\ncsl: ASA.csl\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneeds(tidyverse, rvest)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"vembedr\">\n<div>\n<iframe src=\"https://www.youtube.com/embed/phFPddPPcUk\" width=\"533\" height=\"300\" frameborder=\"0\" allowfullscreen=\"\" data-external=\"1\"></iframe>\n</div>\n</div>\n```\n\n:::\n:::\n\n\nWhen working with data, a significant number of variables will be in some sort of text format. When you want to manipulate these variables, an easy approach would be exporting the data to MS Excel and then just performing those manipulations by hand. This is very time-consuming, though, and, hence, we rather recommend the R way which scales well and works fast for data sets of varying sizes.\n\nQuick reminder: a string is an element of a character vector and can be created by simply wrapping some text in quotation marks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- \"Hi, how are you doing?\"\nvector_of_strings <- c(\"Hi, how are you doing? not good\", \"I'm doing well, HBY?\", \"Me too, thanks for asking.\")\n```\n:::\n\n\nNote that you can either wrap your text in double quotation marks and use single ones in the string and vice versa:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsingle_ones <- \"what's up\"\ndouble_ones <- 'he said: \"I am fine\"'\n```\n:::\n\n\nThe `stringr` package [@wickham_stringr_2019] contains a multitude of commands (49 in total) that can be used to achieve a couple of things, mainly manipulating character vectors, and finding and matching patterns. These goals can also be achieved with base R functions, but `stringr`'s advantage is its consistency. The makers of `stringr` describe it as\n\n> A consistent, simple and easy-to-use set of wrappers around the fantastic `stringi` package. All function and argument names (and positions) are consistent, all functions deal with `NA`'s and zero-length vectors in the same way, and the output from one function is easy to feed into the input of another.\n\nEvery `stringr` function starts with `str_` -- which facilitates finding the proper command: just type `str_` and RStudio's auto-suggest function should take care of the rest (if it doesn't pop up by itself, you can trigger it by hitting the tab key). Also, they take a vector of strings as their first argument, which facilitates using them in a `|>`-pipeline and adding them to a `mutate()`-call.\n\nOne important component of `stringr` functions is regular expressions which will be introduced later as well.\n\n## Basic manipulations\n\nIn the following, we will introduce you to several different operations that can be performed on strings.\n\n### Changing the case of the words\n\nA basic operation is changing words' cases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_lower(vector_of_strings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi, how are you doing? not good\" \"i'm doing well, hby?\"           \n[3] \"me too, thanks for asking.\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_to_upper(vector_of_strings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HI, HOW ARE YOU DOING? NOT GOOD\" \"I'M DOING WELL, HBY?\"           \n[3] \"ME TOO, THANKS FOR ASKING.\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_to_title(vector_of_strings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi, How Are You Doing? Not Good\" \"I'm Doing Well, Hby?\"           \n[3] \"Me Too, Thanks For Asking.\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_to_sentence(vector_of_strings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi, how are you doing? Not good\" \"I'm doing well, hby?\"           \n[3] \"Me too, thanks for asking.\"     \n```\n\n\n:::\n:::\n\n\n### Determining a string's length\n\nDetermining the string's number of characters goes as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_length(vector_of_strings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31 20 26\n```\n\n\n:::\n:::\n\n\n### Extracting particular characters\n\nCharacters can be extracted (by position) using `str_sub`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(vector_of_strings, start = 1, end = 5) # extracting first to fifth character\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi, h\" \"I'm d\" \"Me to\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_sub(vector_of_strings, start = -5, end = -1) # extracting fifth-to-last to last character\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \" good\" \" HBY?\" \"king.\"\n```\n\n\n:::\n:::\n\n\nYou can also use `str_sub()` to replace strings. E.g., to replace the last character by a full stop, you can do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(vector_of_strings, start = -1) <- \".\"\nvector_of_strings\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi, how are you doing? not goo.\" \"I'm doing well, HBY.\"           \n[3] \"Me too, thanks for asking.\"     \n```\n\n\n:::\n:::\n\n\nHowever, in everyday use, you would probably go with `str_replace()` and regular expressions.\n\n### Concatenating strings\n\nSimilar to how `c()` puts together different elements (or vectors of length 1) and other vectors into a single vector, `str_c()` can be used to concatenate several strings into a single string. This can, for instance, be used to write some birthday invitations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Inger\", \"Peter\", \"Kalle\", \"Ingrid\")\n\nstr_c(\"Hi\", names, \"I hope you're doing well. As per this letter, I invite you to my birthday party.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HiIngerI hope you're doing well. As per this letter, I invite you to my birthday party.\" \n[2] \"HiPeterI hope you're doing well. As per this letter, I invite you to my birthday party.\" \n[3] \"HiKalleI hope you're doing well. As per this letter, I invite you to my birthday party.\" \n[4] \"HiIngridI hope you're doing well. As per this letter, I invite you to my birthday party.\"\n```\n\n\n:::\n:::\n\n\nWell, this looks kind of ugly, as there are no spaces, and commas are lacking as well. You can fix that by determining a separator using the `sep` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(\"Hi\", names, \"I hope you're doing well. As per this letter, I invite you to my birthday party.\", sep = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hi, Inger, I hope you're doing well. As per this letter, I invite you to my birthday party.\" \n[2] \"Hi, Peter, I hope you're doing well. As per this letter, I invite you to my birthday party.\" \n[3] \"Hi, Kalle, I hope you're doing well. As per this letter, I invite you to my birthday party.\" \n[4] \"Hi, Ingrid, I hope you're doing well. As per this letter, I invite you to my birthday party.\"\n```\n\n\n:::\n:::\n\n\nYou could also collapse the strings contained in a vector together into one single string using the `collapse` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(names, collapse = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Inger, Peter, Kalle, Ingrid\"\n```\n\n\n:::\n:::\n\n\n### Repetition\n\nRepeating (or duplicating) strings is performed using `str_dup()`. The function takes two arguments: the string to be duplicated and the number of times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_dup(\"felix\", 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"felixfelix\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_dup(\"felix\", 1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"felix\"           \"felixfelix\"      \"felixfelixfelix\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_dup(names, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"IngerInger\"   \"PeterPeter\"   \"KalleKalle\"   \"IngridIngrid\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_dup(names, 1:4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Inger\"                    \"PeterPeter\"              \n[3] \"KalleKalleKalle\"          \"IngridIngridIngridIngrid\"\n```\n\n\n:::\n:::\n\n\n### Removing unnecessary whitespaces\n\nOften text contains unnecessary whitespaces.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunnecessary_whitespaces <- c(\"    on the left\", \"on the right    \", \"    on both sides   \", \"   literally    everywhere  \")\n```\n:::\n\n\nRemoving the ones at the beginning or the end of a string can be accomplished using `str_trim()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_trim(unnecessary_whitespaces, side = \"left\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"on the left\"               \"on the right    \"         \n[3] \"on both sides   \"          \"literally    everywhere  \"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_trim(unnecessary_whitespaces, side = \"right\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"    on the left\"            \"on the right\"              \n[3] \"    on both sides\"          \"   literally    everywhere\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_trim(unnecessary_whitespaces, side = \"both\") # the default option\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"on the left\"             \"on the right\"           \n[3] \"on both sides\"           \"literally    everywhere\"\n```\n\n\n:::\n:::\n\n\n`str_trim()` could not fix the last string though, where unnecessary whitespaces were also present in between words. Here, `str_squish` is more appropriate. It removes leading or trailing whitespaces as well as duplicated ones in between words.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_squish(unnecessary_whitespaces)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"on the left\"          \"on the right\"         \"on both sides\"       \n[4] \"literally everywhere\"\n```\n\n\n:::\n:::\n\n\n### Further links\n\n-   R for Data Science [chapter on `stringr`](https://r4ds.hadley.nz/strings)\n-   The [`stringr` cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf).\n\n### Exercises\n\n1.  Run the following code that downloads movies from IMDb. Clean up the column \"year\" in the resulting film data set. Think about how you could do it with `str_sub()`. Could you also use it for the dot in the \"rank\" column?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneeds(rvest, tidyverse)\nimdb_top250 <- read_html(\"https://www.imdb.com/chart/top/?ref_=nv_mv_250\")\n\nmovies <- tibble(\n  title_raw = imdb_top250 |> \n    html_elements(\".cli-title .ipc-title__text\") |> \n    html_text2(),\n  year_raw = imdb_top250 |> \n    html_elements(\".cli-title-metadata\") |> \n    html_text2()\n) |> \n  separate(title_raw, sep = \" \", into = c(\"rank\", \"title\"), extra = \"merge\")\n```\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmovies_clean <- movies |> \n  mutate(year = str_sub(year_raw, start = 1, end = 4) |> as.double(),\n         rank = str_sub(rank, start = -4, end = -2) |> as.integer())\n```\n:::\n\n:::\n\n\n2.  Convert the following sentence to different cases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsentence <- \"The quick brown fox jumps over the lazy dog.\"\n```\n:::\n\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_lower(sentence)\nstr_to_sentence(sentence)\nstr_to_title(sentence)\nstr_to_upper(sentence)\n```\n:::\n\n   :::\n\n3.  What's the length of the following string?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext <- \"I enjoy studying Sociology at Leipzig University.\"\n```\n:::\n\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_length(text)\n```\n:::\n\n   :::\n\n\n4.  Using the following vectors, create a full sentence:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- \"I am a large language model and I am\"\nattributes <- c(\"powerful.\", \"dumb.\", \"worse at coding than your instructor.\")\nend <- \"Haha, do you really think I asked ChatGPT to give you these exercises?\"\nps <- \"(Of course I did, I am lazy AF.)\"\n```\n:::\n\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(start, attributes, end, ps, sep = \" \")\n```\n:::\n\n   :::\n\n## Regular expressions\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"vembedr\">\n<div>\n<iframe src=\"https://www.youtube.com/embed/e6noZ3zmDxA\" width=\"533\" height=\"300\" frameborder=\"0\" allowfullscreen=\"\" data-external=\"1\"></iframe>\n</div>\n</div>\n```\n\n:::\n:::\n\n\nUp to now, you have been introduced to the more basic functions of the `stringr` package. Those are useful, for sure, yet limited. However, to make use of the full potential of `stringr`, you will first have to acquaint yourself with regular expressions (also often abbreviated as \"RegEx\" with plural \"RegExes\").\n\nThose regular expressions are patterns that can be used to describe certain strings. Exemplary use cases of RegExes are the identification of phone numbers, email addresses, or whether a password you choose on a web page consists of enough characters, an uppercase character, and at least one special character. Hence, if you want to replace certain words with another one, you can write the proper RegEx and it will identify the strings you want to replace, and the `stringr` functions (i.e., `str_replace()`) will take care of the rest.\n\nBefore you dive into RegExes, beware that they are quite complicated at the beginning[^stringr_regex-1]. Yet, mastering them is very rewarding and will pay off in the future.\n\n[^stringr_regex-1]: comment from Felix: \"honestly, I was quite overwhelmed when I encountered them first\"\n\n### Literal characters\n\nThe most basic RegEx patterns consist of literal characters only. `str_view()` tells you which parts of a string match a pattern is present in the element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfive_largest_cities <- c(\"Stockholm\", \"Göteborg\", \"Malmö\", \"Uppsala\", \"Västerås\")\n```\n:::\n\n\n\n\nNote that RegExes are case-sensitive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(five_largest_cities, \"stockholm\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(five_largest_cities, \"Stockholm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <Stockholm>\n```\n\n\n:::\n:::\n\n\nThey also match parts of words:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(five_largest_cities, \"borg\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ Stockholm\n[2] │ Göte<borg>\n[3] │ Malmö\n[4] │ Uppsala\n[5] │ Västerås\n```\n\n\n:::\n:::\n\n\nMoreover, they are \"greedy,\" they only match the first occurrence. `str_locate()` locates the pattern. Look at Stockholm -- we should have two matches here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_locate(five_largest_cities, \"o\") |> \n  as_tibble() |> \n  mutate(city = five_largest_cities)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  start   end city     \n  <int> <int> <chr>    \n1     3     3 Stockholm\n2     6     6 Göteborg \n3    NA    NA Malmö    \n4    NA    NA Uppsala  \n5    NA    NA Västerås \n```\n\n\n:::\n:::\n\n\nThis can be addressed in the `stringr` package by using `str_._all()` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_locate_all(five_largest_cities, \"o\") |> \n  map2(five_largest_cities, \\(x, y) x |> \n         as_tibble() |> \n         mutate(city = y)) |> \n  bind_rows()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  start   end city     \n  <int> <int> <chr>    \n1     3     3 Stockholm\n2     7     7 Stockholm\n3     6     6 Göteborg \n```\n\n\n:::\n:::\n\n\n\nIf you want to match multiple literal characters (or words, for that sake), you can connect them using the `|` meta character (more on meta characters later).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(five_largest_cities, \"Stockholm|Göteborg\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <Stockholm>\n[2] │ <Göteborg>\n[3] │ Malmö\n[4] │ Uppsala\n[5] │ Västerås\n```\n\n\n:::\n:::\n\n\nEvery letter of the English alphabet (or number/or combination of those) can serve as a literal character. Those literal characters *match themselves*. This is, however, not the case with the other sort of characters, so-called meta characters.\n\n### Metacharacters\n\nWhen using RegExes, the following characters are considered meta characters and have a special meaning:\n\n`. \\ | ( ) { } [ ] ^ $ - * + ?`\n\n#### The wildcard\n\nDid you notice how we used the dot to refer to the entirety of the `str_._all()` functions? This is basically what the `.` meta-character does: it matches every character except for a new line. The first call extracts all function names from the `stringr` package, the second one shows the matches (i.e., the elements of the vector where it can find the pattern).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr_functions <- ls(\"package:stringr\")\n\nstr_detect(stringr_functions, \"str_._all\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[61] FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nWell, as you can see, there are none. This is because the `.` can only replace one character. We need some sort of multiplier to find them. The ones available are:\n\n-   `?` -- zero or one\n-   `*` -- zero or more\n-   `+` -- one or more\n-   `{n}` -- exactly n\n-   `{n,}` -- n or more\n-   `{n,m}` -- between n and m\n\nIn our case, the appropriate one is `+`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr_functions[str_detect(stringr_functions, \"str_.+_all\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"str_extract_all\" \"str_locate_all\"  \"str_match_all\"   \"str_remove_all\" \n[5] \"str_replace_all\" \"str_sub_all\"     \"str_view_all\"   \n```\n\n\n:::\n:::\n\n\nBy default, these multipliers are greedy and want to match the longest string possible:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"coco\", \"co*\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <co><co>\n```\n\n\n:::\n:::\n\n\nYou can change this behavior -- make it \"lazy\" -- by adding \"?\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"coco\", \"co*?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <c>o<c>o\n```\n\n\n:::\n:::\n\n\nHere, it only matches the first c, the shortest match possible.\n\nHowever, what if you want to match the character \".\"? This problem might come up when searching for clock time. A naive RegEx might look like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvectors_with_time <- c(\"13500\", \"13M00\", \"13.00\")\n\nstr_view(vectors_with_time, \"13.00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <13500>\n[2] │ <13M00>\n[3] │ <13.00>\n```\n\n\n:::\n:::\n\n\nYet, it matches everything. We need some sort of literal dot. Here, the metacharacter `\\` comes in handy. By putting `\\` in front of the meta character that we want to be treated as literal -- the `.` in our case -- the `.` loses its special meaning and is interpreted as a literal character. This procedure is referred to as \"escaping.\" Hence, `\\` is also referred to as the \"escape character.\" Note that, in R, you will need to escape `\\` as well, and therefore in code escaping will look like this: `\\\\.`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(vectors_with_time, \"13\\\\.00\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ 13500\n[2] │ 13M00\n[3] │ <13.00>\n```\n\n\n:::\n:::\n\n\nBecause this gets tedious quickly in case you have multiple characters that need escaping, you can also use so called raw strings. Another alternative would be using a \"raw string\" (`r\"()\"`). This matches anything inside the raw string -- but you will still need to escape some special characters, but only with one backslash:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimdb_url <- \"imdb.com/chart/top/?ref_=nv_mv_250\"\n\n#imdb_url |> str_view(r\"(?ref_=)\") #throws an error\nimdb_url |> str_view(r\"(\\?ref_=)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ imdb.com/chart/top/<?ref_=>nv_mv_250\n```\n\n\n:::\n:::\n\n\nIf you need to match \"()\", you can also change the opening parentheses: `r\"[]\"` or `r\"{}\"`. If this is not enough, you can also write `r\"---(rawstring)---\"` (you can insert as many dashes as you want to match your string).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparentheses <- \"a * (b + c)\"\n\nparentheses |> str_view(r\"(b \\+)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ a * (<b +> c)\n```\n\n\n:::\n\n```{.r .cell-code}\nparentheses |> str_view(r\"[\\(b \\+]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ a * <(b +> c)\n```\n\n\n:::\n\n```{.r .cell-code}\nsquare_brackets <- \"[a/c + (a*c)]\"\n\nsquare_brackets |> str_view(r\"{\\[a/c}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <[a/c> + (a*c)]\n```\n\n\n:::\n:::\n\n\n### Sets of characters\n\nYou can also define sets of multiple characters using the `[ ]` meta characters. This can be used to define multiple possible characters that can appear in the same place.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_ce <- c(\"spice\", \"space\")\n\nstr_view(sp_ce, \"sp[ia]ce\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <spice>\n[2] │ <space>\n```\n\n\n:::\n:::\n\n\nYou can also define certain ranges of characters using the `-` metacharacter:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_ce <- c(\"spice\", \"space\")\n\nstr_view(sp_ce, \"sp[a-g]ce\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ spice\n[2] │ <space>\n```\n\n\n:::\n:::\n\n\nSame holds for numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\namerican_phone_number <- \"(555) 555-1234\"\n\nstr_view(american_phone_number, \"\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <(555) 555-1234>\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_view(american_phone_number, \"\\\\([:digit:]{3}\\\\) [0-9]{3}-[0-9]{4}\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <(555) 555-1234>\n```\n\n\n:::\n:::\n\n\nThere are also predefined sets of characters, for instance, digits or letters, which are called *character classes*. You can find them on the [`stringr` cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf).\n\nFurthermore, you can put almost every meta character inside the square brackets without escaping them. This does not apply to the caret (`^`) in the first position, the dash `-`, the closing square bracket `]`, and the backslash `\\`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(vector_of_strings, \"[.]\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ Hi, how are you doing? not goo<.>\n[2] │ I'm doing well, HBY<.>\n[3] │ Me too, thanks for asking<.>\n```\n\n\n:::\n:::\n\n\n#### Negating sets of characters\n\nSometimes you will also want to exclude certain sets of characters or words. To achieve this, you can use the `^` meta character at the beginning of the range or set you are defining.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(sp_ce, \"sp[^i]ce\", match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ spice\n[2] │ <space>\n```\n\n\n:::\n:::\n\n\n### Grouping\n\nA related set is using groups of characters. When you do this, those matches take precedence over others. For an example, what would \"ab*\" match? Any number of \"ab\"s, or rather 1 \"a\" and any number of \"b\"s after?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"abbbaaababbbbabab\", \"ab*\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <abbb><a><a><ab><abbbb><ab><ab>\n```\n\n\n:::\n:::\n\n\n The answer is: both. But what if wanted to only match literal \"ab\"s but any number of them and as long as possible? We can use groupings for this.\n\n\n ::: {.cell}\n \n ```{.r .cell-code}\n str_view(\"abbbaaababbbbabab\", \"(ab)*\")\n ```\n \n ::: {.cell-output .cell-output-stdout}\n \n ```\n [1] │ <ab><>b<>b<>a<>a<abab><>b<>b<>b<abab><>\n ```\n \n \n :::\n :::\n\n\nNow the \"ab\"s are seen as an entity and can be multiplied.\n\nAnother useful feature is that you can use groupings and refer to the groups using \\\\1 (for the first group), \\\\2 (for the second group), etc.\n\nThis is for instance handy in an `str_replace()`:\n\n::: {.cell}\n\n```{.r .cell-code}\nwordsalad <- c(\"second The word is out of place\", \"third word The is out of place\")\n\nstr_replace(wordsalad, \"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\2 \\\\1 \\\\3\") |> \n  str_view()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ The second word is out of place\n[2] │ word third The is out of place\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_replace(wordsalad, \"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\3 \\\\1 \\\\2\") |> \n  str_view()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ word second The is out of place\n[2] │ The third word is out of place\n```\n\n\n:::\n:::\n\n\n### Anchors\n\nThere is also a way to define whether you want the pattern to be present in the beginning `^` or at the end `$` of a string. `sentences` are a couple of (i.e., 720) predefined example sentences. If we were now interested in the number of sentences that begin with a \"the,\" we could write the following RegEx:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshortened_sentences <- sentences[1:10]\n\nstr_view(shortened_sentences, regex(\"^the\", ignore_case = TRUE), match = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] │ <The> birch canoe slid on the smooth planks.\n [2] │ Glue the sheet to the dark blue background.\n [3] │ It's easy to tell the depth of a well.\n [4] │ <The>se days a chicken leg is a rare dish.\n [5] │ Rice is often served in round bowls.\n [6] │ <The> juice of lemons makes fine punch.\n [7] │ <The> box was thrown beside the parked truck.\n [8] │ <The> hogs were fed chopped corn and garbage.\n [9] │ Four hours of steady work faced us.\n[10] │ A large size in stockings is hard to sell.\n```\n\n\n:::\n:::\n\n\nIf we wanted to know how many start with a \"The\" and end with a full stop, we could do this one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(shortened_sentences, \"^The.+\\\\.$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <The birch canoe slid on the smooth planks.>\n[4] │ <These days a chicken leg is a rare dish.>\n[6] │ <The juice of lemons makes fine punch.>\n[7] │ <The box was thrown beside the parked truck.>\n[8] │ <The hogs were fed chopped corn and garbage.>\n```\n\n\n:::\n:::\n\n\n#### Boundaries\n\nNote that right now, the RegEx also matches the sentence which starts with a \"These.\" To address this, we need to tell the machine that it should only accept a \"The\" if there starts a new word thereafter. In RegEx syntax, this is done using so-called boundaries. Those are defined as `\\b` as a word boundary and `\\B` as no word boundary. (Note that you will need an additional escape character as you will have to escape the escape character itself.)\n\nIn my example, we would include the former if we were to search for sentences that begin with a single \"The\" and the latter if we were to search for sentences that begin with a word that starts with a \"The\" but are not \"The\" -- such as \"These.\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(shortened_sentences, \"^The\\\\b.+\\\\.$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <The birch canoe slid on the smooth planks.>\n[6] │ <The juice of lemons makes fine punch.>\n[7] │ <The box was thrown beside the parked truck.>\n[8] │ <The hogs were fed chopped corn and garbage.>\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_view(shortened_sentences, \"^The\\\\B.+\\\\.$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[4] │ <These days a chicken leg is a rare dish.>\n```\n\n\n:::\n:::\n\n\n#### Lookarounds\n\nA final common task is to extract certain words or values based on what comes before or after them. Look at the following example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheights <- c(\"1m30cm\", \"2m01cm\", \"3m10cm\")\n```\n:::\n\n\nHere, to identify the height in meters, the first task is to identify all the numbers that are followed by an \"m\". The RegEx syntax for this looks like this: `A(?=pattern)` with `A` being the entity that is supposed to be found (hence, in this case, \\[0-9\\]+).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(heights, \"[0-9]+(?=m)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <1>m30cm\n[2] │ <2>m01cm\n[3] │ <3>m10cm\n```\n\n\n:::\n:::\n\n\nThe second step now is to identify the centimeters. This could of course be achieved using the same RegEx and replacing `m` with `cm`. However, we can also harness a so-called negative look ahead `A(?!pattern)`, a so-called look behind `(?<=pattern)A`. The negative counterpart, the negative look behind `(?<!pattern)A` could be used to extract the meters.\n\nThe negative lookahead returns everything that is not followed by the defined pattern. The look behind returns everything that is preceded by the pattern, the negative look behind returns everything that is not preceded by the pattern.\n\nIn the following, we demonstrate how you could extract the centimeters using negative look ahead and look behind.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(heights, \"[0-9]+(?!m)\") # negative look ahead\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ 1m<30>cm\n[2] │ 2m<01>cm\n[3] │ 3m<10>cm\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(heights, \"(?<=m)[0-9]+\") # look behind\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ 1m<30>cm\n[2] │ 2m<01>cm\n[3] │ 3m<10>cm\n```\n\n\n:::\n:::\n\n\n### Further links\n\n-   R for Data Science [chapter on RegExes](https://r4ds.hadley.nz/regexps.html)\n-   A [YouTube video](https://www.youtube.com/watch?v=NvHjYOilOf8) on RegExes by Johns Hopkins professor Roger Peng.\n-   And a [chapter](https://bookdown.org/rdpeng/rprogdatascience/regular-expressions.html#the-stringr-package) by Roger Peng.\n-   A [website for practicing RegExes](https://RegExone.com).\n\n### Exercises\n\n1.  Write a RegEx for Swedish mobile numbers. Test it with `str_detect(\"+46 71-738 25 33\", \"[insert your RegEx here]\")`.\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(\"+46 71-738 25 33\", \"\\\\+46 [0-9]{2}\\\\-[0-9]{3} [0-9]{2} [0-9]{2}\")\n```\n:::\n\n   :::\n\n2.  Given the vector `c(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\")`, use a regular expression to identify fruits that contain the letter \"a\" exactly three times.\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\")\nstr_detect(fruits, \"^([^a]*a){3}[^a]*$\")\n\n# alternatively\nstr_count(fruits, \"a\") == 3\n```\n:::\n\n   :::\n\n3.  Given the sentence vector `c(\"The cat sat on the mat.\", \"Mat is what it sat on.\", \"On the mat, it sat.\")`, write a regular expression to identify sentences that start with \"The\" and end with \"mat.\".\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats <- c(\"The cat sat on the mat.\", \"Mat is what it sat on.\", \"On the mat, it sat.\")\nstr_detect(cats, \"^The.*mat.$\")\n```\n:::\n\n   :::\n\n4.  Extract all email addresses from the following vector: `c(\"john.doe@example.com\", \"alice_smith@company.net\", \"r.user@domain.org\", \"I am @ the office RN\", \"facebook.com\")`.\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses <- c(\"john.doe@example.com\", \"alice_smith@company.net\", \"r.user@domain.org\", \"I am @ the office RN\", \"facebook.com\")\n\nstr_detect(addresses, \"[a-z.\\\\_]+\\\\@[a-z]+\\\\.[a-z]+\")\n```\n:::\n\n   :::\n\n5.  Check a vector of passwords for strength. A strong password should have at least 8 characters, include an uppercase and a lowercase letter, a number, and a special character (e.g., !\\@#\\$%\\^&\\*).\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n  \n\n::: {.cell}\n\n```{.r .cell-code}\npassword <- c(\"Hi!123456\")\n\nif (str_detect(password, \"[A-Z]{1,}\") &\n    str_detect(password, \"[a-z]{1,}\") &\n    str_detect(password, \"[0-9]{1,}\") &\n    str_detect(password, \"[\\\\!\\\\@\\\\#\\\\$\\\\%\\\\^\\\\&\\\\*]{1,}\") &\n    str_length(password) > 7){\n  \"strong password\"\n}else{\n  \"weak password\"\n}\n```\n:::\n\n   :::\n\n6.  From \"The theme of this theater is therapeutic.\", extract all words that start with \"the\" but are not followed by \"me\".\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsentence <- \"The theme of this theater is therapeutic.\" |> str_to_lower()\nstr_extract_all(sentence, \"\\\\bthe(?!me)\\\\w*\\\\b\")\n```\n:::\n\n   :::\n\n## More advanced string manipulation\n\nNow that you have learned about RegExes, you can unleash the full power of `stringr`.\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"vembedr\">\n<div>\n<iframe src=\"https://www.youtube.com/embed/D7H6fe9bXU8\" width=\"533\" height=\"300\" frameborder=\"0\" allowfullscreen=\"\" data-external=\"1\"></iframe>\n</div>\n</div>\n```\n\n:::\n:::\n\n\nThe basic syntax of a `stringr` function looks as follows: `str_.*(string, regex(\"\"))`. Some `stringr` functions also have the suffix `_all` which implies that they operate not only on the first match (\"greedy\") but on every match.\n\nTo demonstrate the different functions, we will again rely on the subset of example sentences.\n\n### Detect matches\n\n`str_detect` can be used to determine whether a certain pattern is present in the string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(shortened_sentences, \"The\\\\b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nThis also works very well in a `dplyr::filter()` call. Finding all action movies in the IMDB data set can be solved like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimdb_raw <- read_csv(\"https://www.dropbox.com/s/81o3zzdkw737vt0/imdb2006-2016.csv?dl=1\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 1000 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): Title, Genre, Description, Director, Actors\ndbl (7): Rank, Year, Runtime (Minutes), Rating, Votes, Revenue (Millions), M...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nimdb_raw |> \n  filter(str_detect(Genre, \"Adventure\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 259 × 12\n    Rank Title       Genre Description Director Actors  Year `Runtime (Minutes)`\n   <dbl> <chr>       <chr> <chr>       <chr>    <chr>  <dbl>               <dbl>\n 1     1 Guardians … Acti… A group of… James G… Chris…  2014                 121\n 2     2 Prometheus  Adve… Following … Ridley … Noomi…  2012                 124\n 3     5 Suicide Sq… Acti… A secret g… David A… Will …  2016                 123\n 4     6 The Great … Acti… European m… Yimou Z… Matt …  2016                 103\n 5     9 The Lost C… Acti… A true-lif… James G… Charl…  2016                 141\n 6    10 Passengers  Adve… A spacecra… Morten … Jenni…  2016                 116\n 7    11 Fantastic … Adve… The advent… David Y… Eddie…  2016                 133\n 8    13 Rogue One   Acti… The Rebel … Gareth … Felic…  2016                 133\n 9    14 Moana       Anim… In Ancient… Ron Cle… Auli'…  2016                 107\n10    16 The Secret… Anim… The quiet … Chris R… Louis…  2016                  87\n# ℹ 249 more rows\n# ℹ 4 more variables: Rating <dbl>, Votes <dbl>, `Revenue (Millions)` <dbl>,\n#   Metascore <dbl>\n```\n\n\n:::\n:::\n\n\nIf you want to know whether there are multiple matches present in each string, you can use `str_count`. Here, it might be advisable to set the `ignore_case` option to `TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_count(shortened_sentences, regex(\"the\\\\b\", ignore_case = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 2 2 1 0 0 1 2 1 0 0\n```\n\n\n:::\n:::\n\n\nIf you want to locate the match in the string, use `str_locate`. This returns a matrix, which is a vector of multiple dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_locate(shortened_sentences, regex(\"The\\\\b\", ignore_case = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      start end\n [1,]     1   3\n [2,]     6   8\n [3,]    19  21\n [4,]    NA  NA\n [5,]    NA  NA\n [6,]     1   3\n [7,]     1   3\n [8,]     1   3\n [9,]    NA  NA\n[10,]    NA  NA\n```\n\n\n:::\n:::\n\n\nMoreover, this is a good example for the greediness of `stringr` functions. Hence, it is advisable to use `str_locate_all` which returns a list with one matrix for each element of the original vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_locate_all(shortened_sentences, regex(\"The\\\\b\", ignore_case = TRUE)) |> pluck(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     start end\n[1,]     1   3\n[2,]    25  27\n```\n\n\n:::\n:::\n\n\n### Mutating strings\n\nMutating strings usually implies the replacement of certain elements (e.g., words) with other elements (or removing them, which is a special case of replacing them with nothing). In `stringr` this is performed using `str_replace(string, pattern, replacement)` and `str_replace_all(string, pattern, replacement)`.\n\nIf we wanted, for instance, to replace the first occurrence of \"m\" letters with \"meters,\" we would go about this the following way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace(heights, \"m\", \"meters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1meters30cm\" \"2meters01cm\" \"3meters10cm\"\n```\n\n\n:::\n:::\n\n\nNote that `str_replace_all` would have lead to the following outcome:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace_all(heights, \"m\", \"meters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1meters30cmeters\" \"2meters01cmeters\" \"3meters10cmeters\"\n```\n\n\n:::\n:::\n\n\nHowever, we also want to replace the \"cm\" with \"centimeters,\" hence, we can harness another feature of `str_replace_all()`, providing multiple replacements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace_all(heights, c(\"cm\" = \"centimeters\", \"m\" = \"meters\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1meters30centimeterseters\" \"2meters01centimeterseters\"\n[3] \"3meters10centimeterseters\"\n```\n\n\n:::\n:::\n\n\nWhat becomes obvious is that a \"simple\" RegEx containing just literal characters more often than not does not suffice. It will be your task to fix this. And while on it, you can also address the meter/meters problem -- a \"1\" needs meter instead of meters. Another feature is that the replacements are performed in order. You can harness this for solving the problem.\n\n### Extracting text\n\n`str_extract(_all)()` can be used to extract matching strings. In the `mtcars` data set, the first word describes the car brand. Here, we harness another RegEx, the `\\\\w` which stands for any word character. Its opponent is `\\\\W` for any non-word character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n  rownames_to_column(var = \"car_model\") |> \n  transmute(manufacturer = str_extract(car_model, \"^\\\\w+\\\\b\")) |> \n  head(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  manufacturer\n1        Mazda\n2        Mazda\n3       Datsun\n4       Hornet\n5       Hornet\n6      Valiant\n```\n\n\n:::\n:::\n\n\n### Split vectors\n\nAnother use case here would have been to split it into two columns: manufacturer and model. One approach would be to use `str_split()`. This function splits the string at every occurrence of the predefined pattern. In this example, we use a word boundary as the pattern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmanufacturer_model <- rownames(mtcars)\nstr_split(manufacturer_model, \"\\\\b\") |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"\"      \"Mazda\" \" \"     \"RX4\"   \"\"     \n\n[[2]]\n[1] \"\"      \"Mazda\" \" \"     \"RX4\"   \" \"     \"Wag\"   \"\"     \n\n[[3]]\n[1] \"\"       \"Datsun\" \" \"      \"710\"    \"\"      \n\n[[4]]\n[1] \"\"       \"Hornet\" \" \"      \"4\"      \" \"      \"Drive\"  \"\"      \n\n[[5]]\n[1] \"\"           \"Hornet\"     \" \"          \"Sportabout\" \"\"          \n\n[[6]]\n[1] \"\"        \"Valiant\" \"\"       \n```\n\n\n:::\n:::\n\n\nThis outputs a list containing the different singular words/special characters. This doesn't make sense in this case. Here, however, the structure of the string is always roughly the same: \"\\\\\\[manufacturer\\\\\\]\\\\\\[ \\\\\\]\\\\\\[model description\\\\\\]\". Moreover, the manufacturer is only one word. Hence, the task can be fixed by splitting the string after the first word, which should indicate the manufacturer. This can be accomplished using `str_split_fixed()`. Fixed means that the number of splits is predefined. This returns a matrix that can easily become a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_split_fixed(manufacturer_model, \"(?<=\\\\w)\\\\b\", n = 2) |> \n  as_tibble() |> \n  rename(manufacturer = V1,\n         model = V2) |> \n  mutate(model = str_squish(model))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 2\n   manufacturer model       \n   <chr>        <chr>       \n 1 Mazda        \"RX4\"       \n 2 Mazda        \"RX4 Wag\"   \n 3 Datsun       \"710\"       \n 4 Hornet       \"4 Drive\"   \n 5 Hornet       \"Sportabout\"\n 6 Valiant      \"\"          \n 7 Duster       \"360\"       \n 8 Merc         \"240D\"      \n 9 Merc         \"230\"       \n10 Merc         \"280\"       \n# ℹ 22 more rows\n```\n\n\n:::\n:::\n\n\n### Further links\n\nLook at the \"Further links\" provided above.\n\n### Exercises\n\n1.  Run the following code that downloads movies from IMDb. Create a tibble with the two columns \"rank\" and \"title\" by extracting the respective part of the raw title.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneeds(rvest, tidyverse)\nimdb_top250 <- read_html(\"https://www.imdb.com/chart/top/?ref_=nv_mv_250\")\n\nraw_title <- imdb_top250 |> \n    html_elements(\".cli-title .ipc-title__text\") |> \n    html_text2()\n```\n:::\n\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  rank = raw_title |> str_extract(\"^[0-9]{1,3}\") |> as.integer(),\n  title = raw_title |> str_remove(\"^[0-9]{1,3}\\\\. \")\n)\n```\n:::\n\n   :::\n\n2.  Replace m and cm appropriately in the vector of heights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheights <- c(\"1m30cm\", \"2m01cm\", \"3m10cm\")\n```\n:::\n\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace_all(heights, c(\"(?<=[2-9]{1})m\" = \"meters\", \n                           \"(?<=[0-9]{2})m\" = \"meters\", \n                           \"(?<=1)m\" = \"meter\", \n                           \"(?<=01)cm$\" = \"centimeter\", \n                           \"cm$\" = \"centimeters\"))\n```\n:::\n\n   :::\n\n3.  Run the following code and clean up the resulting table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneeds(rvest, janitor, lubridate, tidyverse)\n\nsenator_table_raw <- read_html(\"https://en.wikipedia.org/wiki/List_of_current_United_States_senators\") |> \n  html_elements(css = \"#senators\") |> \n  html_table() |> \n  pluck(1) |> \n  clean_names() |> \n  select(state, senator, party = party_2, born, occupations = occupation_s, assumed_office)\n```\n:::\n\n\na.  Remove the footnotes in the \"party\" column.\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsenator_table_party_cleaned <- senator_table_raw |> \n  mutate(party = str_remove_all(party, \"\\\\[.\\\\]|\\\\(.+\\\\)\"))\n```\n:::\n\n   :::\n\nb.  Bring their date of birth (\"born\") in proper shape.\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsenator_table_born_party_cleaned <- senator_table_party_cleaned |> \n  mutate(born = str_extract(born, \"19[0-9]{2}\\\\-[01][0-9]\\\\-[0-3][0-9]\") |> ymd())\n```\n:::\n\n   :::\n\nc.  Bonus: fix their \"occupation\" by separating the single jobs (combine look-ahead and -behind for that.)\n\n   ::: {.callout-note collapse=\"true\" title=\"Solution\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsenator_table_cleaned <- senator_table_born_party_cleaned |> \n  mutate(occupation_clean = str_replace_all(occupations, c(\"(?<=[a-z])(?=[A-Z])\" = \"; \", \"CEO\" = \"CEO \")) |> \n           str_squish())\n```\n:::\n\n   :::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/vembedr-0.1.5/css/vembedr.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}